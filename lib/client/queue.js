// Generated by CoffeeScript 1.6.3
var deferred, queue;

deferred = require('../support').deferred;

queue = void 0;

exports.testable = function() {
  return queue;
};

exports.Queue = function(config) {
  var api;
  if (config == null) {
    config = {};
  }
  queue = {
    sequence: 0,
    suspended: false,
    pending: {
      count: 0,
      items: {}
    },
    active: {
      count: 0,
      items: {}
    },
    redo: {
      count: 0,
      items: {}
    },
    finished: {
      count: 0
    },
    enqueue: deferred(function(action, object) {
      if (queue.pending.count === config.queueLimit) {
        return action.reject(new Error('dinkum queue overflow'));
      }
      object.sequence = ++queue.sequence;
      queue.pending.items[queue.sequence.toString()] = object;
      queue.pending.count++;
      return action.resolve();
    }),
    dequeue: deferred(function(action) {
      return process.nextTick(function() {
        var object, seq, slots;
        if (queue.suspended) {
          return action.resolve([]);
        }
        slots = config.requestLimit - queue.active.count;
        return action.resolve(((function() {
          var _results;
          _results = [];
          for (seq in queue.redo.items) {
            if (--slots < 0) {
              break;
            }
            object = queue.redo.items[seq];
            queue.active.items[seq] = object;
            delete queue.redo.items[seq];
            queue.active.count++;
            queue.redo.count--;
            _results.push(object);
          }
          return _results;
        })()).concat((function() {
          var _results;
          _results = [];
          for (seq in queue.pending.items) {
            if (--slots < 0) {
              break;
            }
            object = queue.pending.items[seq];
            queue.active.items[seq] = object;
            delete queue.pending.items[seq];
            queue.active.count++;
            queue.pending.count--;
            _results.push(object);
          }
          return _results;
        })()));
      });
    }),
    requeue: deferred(function(action, object) {
      var error, seq;
      try {
        seq = object.sequence.toString();
        queue.redo.items[seq] = object;
        queue.redo.count++;
        delete queue.active.items[seq];
        queue.active.count--;
        return action.resolve();
      } catch (_error) {
        error = _error;
        return action.reject(error);
      }
    }),
    update: deferred(function(action, state, object) {
      var error, seq;
      try {
        switch (state) {
          case 'done':
            seq = object.sequence.toString();
            if (queue.active.items[seq] != null) {
              queue.active.count--;
              delete queue.active.items[seq];
              queue.finished.count++;
            }
        }
        return action.resolve();
      } catch (_error) {
        error = _error;
        return action.reject(error);
      }
    }),
    stats: deferred(function(action) {
      return action.resolve({
        pending: {
          count: queue.pending.count
        },
        active: {
          count: queue.active.count
        },
        done: {
          count: queue.finished.count
        }
      });
    })
  };
  api = {
    enqueue: queue.enqueue,
    dequeue: queue.dequeue,
    requeue: queue.requeue,
    update: queue.update,
    stats: queue.stats
  };
  Object.defineProperty(api, 'suspend', {
    get: function() {
      return queue.suspended = true;
    }
  });
  return Object.defineProperty(api, 'resume', {
    get: function() {
      return queue.suspended = false;
    }
  });
};
