// Generated by CoffeeScript 1.6.3
var deferred, queue;

deferred = require('../support').deferred;

queue = void 0;

exports.testable = function() {
  return queue;
};

exports.queue = function(config) {
  var api;
  if (config == null) {
    config = {};
  }
  queue = {
    sequence: 0,
    pending: {
      count: 0,
      items: {}
    },
    active: {
      count: 0,
      items: {}
    },
    done: {
      count: 0
    },
    enqueue: deferred(function(action, object) {
      if (queue.pending.count === config.queueLimit) {
        return action.reject(new Error('dinkum queue overflow'));
      }
      object.sequence = ++queue.sequence;
      object.onDone = function(error) {
        var seq;
        seq = object.sequence.toString();
        delete queue.active.items[seq];
        queue.active.count--;
        return console.log({
          REMAINING: {
            pending: queue.pending.count,
            active: queue.active.count
          }
        });
      };
      queue.pending.items[queue.sequence.toString()] = object;
      queue.pending.count++;
      return action.resolve();
    }),
    dequeue: deferred(function(action) {
      return process.nextTick(function() {
        var object, seq, slots;
        slots = config.requestLimit - queue.active.count;
        return action.resolve((function() {
          var _results;
          _results = [];
          for (seq in queue.pending.items) {
            if (--slots < 0) {
              break;
            }
            object = queue.pending.items[seq];
            queue.active.items[seq] = object;
            delete queue.pending.items[seq];
            queue.active.count++;
            queue.pending.count--;
            _results.push(object);
          }
          return _results;
        })());
      });
    }),
    queue: {
      stats: deferred(function(action) {
        return action.resolve({
          pending: {
            count: queue.pending.count
          },
          active: {
            count: queue.active.count
          }
        });
      })
    }
  };
  return api = {
    enqueue: queue.enqueue,
    dequeue: queue.dequeue,
    queue: queue.queue
  };
};
