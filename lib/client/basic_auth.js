// Generated by CoffeeScript 1.6.3
var CookieStore, defer, https;

https = require('https');

defer = require('when').defer;

CookieStore = require('./cookie_store');

exports.create = function(config) {
  var active, authenticating, done, queued, sequence, session;
  if (!((config != null) && (config.username != null) && (config.password != null) && (config.hostname != null))) {
    throw new Error('BasicAuth.create(config) requires config.username, config.password, config.hostname');
  }
  config.port || (config.port = 443);
  if (config.rateLimit == null) {
    config.rateLimit = 10;
  }
  queued = {};
  active = {};
  done = {
    total: 0
  };
  authenticating = 0;
  sequence = 1;
  session = {
    cookies: CookieStore.create({
      hostname: config.username
    }),
    get: function(opts, promise) {
      var seq, slots;
      if (opts == null) {
        opts = {};
      }
      if (promise == null) {
        promise = defer();
      }
      promise.sequence || (promise.sequence = ++sequence);
      opts.method = 'GET';
      opts.path || (opts.path = '/');
      opts.headers || (opts.headers = {});
      if (authenticating) {
        if (promise.sequence === authenticating) {
          session.dequeue({
            opts: opts,
            promise: promise
          });
          return promise.promise;
        }
        queued[promise.sequence.toString()] = {
          statusAt: Date.now(),
          status: 'pending auth',
          promise: promise,
          opts: opts
        };
        return promise.promise;
      }
      queued[promise.sequence.toString()] = {
        statusAt: Date.now(),
        status: 'rate limit',
        promise: promise,
        opts: opts
      };
      slots = config.rateLimit - session.active;
      for (seq in queued) {
        if (slots-- === 0) {
          break;
        }
        session.dequeue(queued[seq]);
      }
      return promise.promise;
    },
    dequeue: function(_arg) {
      var cookie, opts, promise, request;
      opts = _arg.opts, promise = _arg.promise;
      active[promise.sequence.toString()] = {
        status: 'dqueue',
        statusAt: Date.now(),
        promise: promise,
        opts: opts
      };
      delete queued[promise.sequence.toString()];
      cookie = session.cookies.getCookie();
      if (cookie != null) {
        opts.headers.cookie = cookie;
      }
      request = https.request({
        hostname: config.hostname,
        port: config.port,
        path: opts.path,
        auth: authenticating === promise.sequence ? opts.auth : void 0,
        method: opts.method,
        headers: opts.headers
      }, function(response) {
        var result, track;
        if (track = active[promise.sequence.toString()]) {
          track.status = 'connected';
          track.statusAt = Date.now();
        }
        if (response.statusCode === 401) {
          if (authenticating) {
            if (authenticating === promise.sequence) {
              authenticating = 0;
              promise.reject(new Error('Authentication Failed'));
              return;
            } else {
              queued[promise.sequence.toString()] = {
                status: 'pending auth',
                statusAt: Date.now(),
                promise: promise,
                opts: opts
              };
              return;
            }
          }
          authenticating = promise.sequence;
          opts.auth = "" + config.username + ":" + config.password;
          session.get(opts, promise);
        } else {
          if (authenticating) {
            if (promise.sequence === authenticating) {
              authenticating = 0;
            }
          }
        }
        result = {
          statusCode: response.statusCode,
          headers: response.headers,
          body: ''
        };
        response.on('data', function(chunk) {
          return result.body += chunk.toString();
        });
        return response.on('end', function() {
          var seq, slots, _results;
          done.total++;
          delete active[promise.sequence.toString()];
          promise.resolve(result);
          slots = config.rateLimit - session.active;
          _results = [];
          for (seq in queued) {
            if (slots-- === 0) {
              break;
            }
            _results.push(session.dequeue(queued[seq]));
          }
          return _results;
        });
      });
      active[promise.sequence.toString()].status = 'sent';
      active[promise.sequence.toString()].statusAt = Date.now();
      return promise.promise;
    },
    queued: {},
    active: {},
    status: function() {
      var now, pended, sended, seq, _fn, _fn1;
      pended = {
        count: 0,
        requests: {}
      };
      sended = {
        count: 0,
        requests: {}
      };
      now = Date.now();
      _fn = function(seq) {
        pended.count++;
        return pended.requests[seq] = {
          status: queued[seq].status,
          statusAge: now - queued[seq].statusAt,
          path: queued[seq].opts.path
        };
      };
      for (seq in queued) {
        _fn(seq);
      }
      _fn1 = function(seq) {
        sended.count++;
        return sended.requests[seq] = {
          status: active[seq].status,
          statusAge: now - active[seq].statusAt,
          path: active[seq].opts.path
        };
      };
      for (seq in active) {
        _fn1(seq);
      }
      return {
        queued: pended,
        active: sended,
        done: done
      };
    }
  };
  Object.defineProperty(session, 'queued', {
    enumarable: true,
    get: function() {
      var count, seq;
      count = 0;
      for (seq in queued) {
        count++;
      }
      return count;
    }
  });
  return Object.defineProperty(session, 'active', {
    enumarable: true,
    get: function() {
      var count, seq;
      count = 0;
      for (seq in active) {
        count++;
      }
      return count;
    }
  });
};
