// Generated by CoffeeScript 1.6.3
var Authenticator, deferred, enclose, testable, _ref;

_ref = require('../support'), enclose = _ref.enclose, deferred = _ref.deferred;

Authenticator = require('./authenticator').Authenticator;

testable = void 0;

exports._transport = function() {
  return testable;
};

exports.Transport = enclose(Authenticator, function(authenticator, config, queue) {
  var api, options, transport;
  if (config.transport === 'https') {
    options = require('https').globalAgent.options;
    options.rejectUnauthorized = !config.allowUncertified;
  }
  transport = {
    queue: queue,
    authenticator: authenticator,
    request: deferred(function(action, httpRequest) {
      var notify, opts, promised, reject, request, requestOpts, resolve, sequence;
      resolve = action.resolve, reject = action.reject, notify = action.notify;
      opts = httpRequest.opts, promised = httpRequest.promised, sequence = httpRequest.sequence;
      if (authenticator.type === 'request') {
        if (!authenticator.requestAuth(httpRequest)) {
          reject();
          return;
        }
      }
      requestOpts = {};
      if (config.port != null) {
        requestOpts.port = config.port;
      }
      requestOpts.hostname = config.hostname;
      requestOpts.method = opts.method;
      requestOpts.path = opts.path;
      if (opts.auth != null) {
        requestOpts.auth = opts.auth;
      }
      httpRequest.state = 'create';
      request = require(config.transport).request(requestOpts, function(response) {
        var resultObj;
        httpRequest.state = 'response';
        resultObj = {
          statusCode: response.statusCode,
          headers: response.headers,
          body: ''
        };
        response.on('data', function(chunk) {
          httpRequest.state = 'receive';
          return resultObj.body += chunk.toString();
        });
        response.on('error', function(error) {
          return console.log({
            UNHANDLED_ERROR: error
          });
        });
        return response.on('end', function() {
          var error;
          if (resultObj.statusCode === 401) {
            if (transport.authenticator.type !== 'session') {
              reject();
              error = new Error('dinkum authentication failure (request)');
              error.detail = {
                request: requestOpts,
                response: resultObj
              };
              httpRequest.promised.reject(error);
              return;
            }
            httpRequest.state = 'authenticating';
            return transport.authenticator.sessionAuth(httpRequest).then(function(authRequest) {
              if (authRequest != null) {
                return transport.request(authRequest).then(resolve, reject, notify);
              }
            }, reject, notify);
          } else {
            httpRequest.state = 'done';
            return queue.update('done', httpRequest).then(function() {
              resolve();
              return promised.resolve(resultObj);
            }, reject, notify);
          }
        });
      });
      request.on('socket', function(socket) {
        if (config.connectTimeout !== 0) {
          socket.setTimeout(config.connectTimeout);
          return socket.on('timeout', function() {
            var error, msg;
            request.abort();
            msg = 'dinkum connect timeout';
            error = new Error(msg);
            error.detail = {
              request: requestOpts
            };
            httpRequest.state = 'done';
            httpRequest.error = error;
            return queue.update('done', httpRequest).then(function() {
              reject();
              return promised.reject(error);
            }, reject, notify);
          });
        }
      });
      request.on('error', function(error) {
        var msg;
        if (error.message === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
          msg = 'dinkum encounter with uncertified server';
          msg += ' (use config.allowUncertified to trust it)';
          error = new Error(msg);
          error.detail = {
            request: requestOpts
          };
          httpRequest.state = 'done';
          httpRequest.error = error;
          queue.update('done', httpRequest).then(function() {
            reject();
            return promised.reject(error);
          }, reject, notify);
          return;
        }
        error.detail = {
          request: requestOpts
        };
        return queue.update('done', httpRequest).then(function() {
          reject();
          return promised.reject(error);
        }, reject, notify);
      });
      request.end();
      return httpRequest.state = 'sent';
    })
  };
  testable = transport;
  return api = {
    request: transport.request
  };
});
